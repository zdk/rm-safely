#!/usr/bin/env bash

VERSION="1.7.0"
HOOK_FILE="$HOME/.rm-safely"

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

detect_shell() {
    case "$SHELL" in
    */zsh)
        for f in "${ZDOTDIR:-}/.zshrc" "$HOME/.zshrc" \
            "${XDG_CONFIG_HOME:-$HOME/.config}/zsh/.zshrc"; do
            [ -f "$f" ] && SHELL_CONFIG="$f" && return
        done
        ;;
    */bash)
        for f in "$HOME/.bashrc" \
            "${XDG_CONFIG_HOME:-$HOME/.config}/bash/.bashrc"; do
            [ -f "$f" ] && SHELL_CONFIG="$f" && return
        done
        ;;
    esac
}

create_hook_file() {
    cat >"$HOOK_FILE" <<'EOF'
# rm-safely - rm alias that moves files to a trash directory before deletion

VERSION=__VERSION_PLACEHOLDER__
UNDO_STACK="$HOME/.rm-safely-undo-stack"
UNDO_LIMIT=100

get_mount_point() {
    local file="$1"
    df "$file" 2>/dev/null | tail -1 | awk '{print $NF}'
}

get_trash_dir() {
    local file="$1"
    local home_mount=$(get_mount_point "$HOME")
    local file_mount=$(get_mount_point "$file")

    if [ "$home_mount" = "$file_mount" ]; then
        echo "${HOME}/.local/share/Trash"
    else
        echo "${file_mount}/.Trash-$(id -u)"
    fi
}

get_all_trash_dirs() {
    local trash_dirs=()

    if [ -d "${HOME}/.local/share/Trash" ]; then
        trash_dirs+=("${HOME}/.local/share/Trash")
    fi

    local home_mount=$(get_mount_point "$HOME")
    local uid=$(id -u)
    for mount in $(df -h | tail -n +2 | awk '{print $NF}' | grep -v "^${home_mount}$"); do
        if [ -d "${mount}/.Trash-${uid}" ]; then
            trash_dirs+=("${mount}/.Trash-${uid}")
        fi
    done

    printf '%s\n' "${trash_dirs[@]}"
}

add_to_undo_stack() {
    local trash_name="$1"
    local trash_dir="$2"
    echo "${trash_name}|${trash_dir}" >> "$UNDO_STACK"

    if [ -f "$UNDO_STACK" ]; then
        local line_count=$(wc -l < "$UNDO_STACK")
        if [ "$line_count" -gt "$UNDO_LIMIT" ]; then
            local lines_to_keep=$((line_count - UNDO_LIMIT))
            tail -n "$UNDO_LIMIT" "$UNDO_STACK" > "${UNDO_STACK}.tmp"
            mv "${UNDO_STACK}.tmp" "$UNDO_STACK"
        fi
    fi
}

pop_from_undo_stack() {
    if [ ! -f "$UNDO_STACK" ] || [ ! -s "$UNDO_STACK" ]; then
        return 1
    fi

    local last_entry=$(tail -n 1 "$UNDO_STACK")
    if [ -z "$last_entry" ]; then
        return 1
    fi

    case "$last_entry" in
        *\|*) ;;  # Contains pipe, valid
        *) return 1 ;;  # No pipe, invalid
    esac

    sed -i.bak '$ d' "$UNDO_STACK"
    /bin/rm -f "${UNDO_STACK}.bak"

    echo "$last_entry"
    return 0
}

rm() {
    setopt local_options null_glob 2>/dev/null || true
    local HOME_TRASH_DIR="${HOME}/.local/share/Trash"
    mkdir -p "${HOME_TRASH_DIR}/files" "${HOME_TRASH_DIR}/info" 2>/dev/null

    case "$1" in
        --rm)
            shift
            local has_r=0
            local has_f=0
            local has_i=0
            for arg in "$@"; do
                case "$arg" in
                    -*r*) has_r=1 ;;
                esac
                case "$arg" in
                    -*f*) has_f=1 ;;
                esac
                case "$arg" in
                    -*i*) has_i=1 ;;
                esac
            done

            local has_rf=0
            if [ $has_r -eq 1 ] && [ $has_f -eq 1 ]; then
                has_rf=1 # Both -r and -f are present
            fi

            if [ $has_rf -eq 1 ] || [ $has_i -eq 0 ]; then
                echo "WARNING: Permanently remove ?"
                echo -n "Type 'yes' to confirm: "
                read -r response
                if [ "$response" != "yes" ]; then
                    echo "Cancelled."
                    return 1
                fi
            fi

            /bin/rm "$@"
            ;;
        --empty-trash)
            echo "WARNING: Permanently delete all files in trash?"
            echo -n "Type 'yes' to confirm: "
            read -r response
            if [ "$response" != "yes" ]; then
                echo "Cancelled."
                return 1
            fi

            local found_trash=0
            while IFS= read -r trash_dir; do
                if [ -d "$trash_dir/files" ] && [ -n "$(ls -A "$trash_dir/files" 2>/dev/null)" ]; then
                    /bin/rm -rf "$trash_dir/files"/* "$trash_dir/info"/*
                    echo "Emptied trash at: $trash_dir"
                    found_trash=1
                fi
            done < <(get_all_trash_dirs)

            if [ $found_trash -eq 0 ]; then
                echo "All trash directories are empty"
            fi
            ;;
        --list-trash|-l)
            local has_files=0
            echo "Trash Contents:"
            echo "==============="
            echo "Hash    | Filename                                 | Original Path"
            echo "--------|------------------------------------------|--------------"

            while IFS= read -r trash_dir; do
                local trash_files="$trash_dir/files"
                local trash_info="$trash_dir/info"

                if [ -d "$trash_files" ] && [ -n "$(ls -A "$trash_files" 2>/dev/null)" ]; then
                    for file in "$trash_files"/*; do
                        [ -e "$file" ] || continue
                        basename="$(basename "$file")"
                        info_file="$trash_info/${basename}.info"
                        # Generate short hash from filename
                        hash=$(echo -n "$basename" | sha256sum | cut -c1-6)
                        if [ -f "$info_file" ]; then
                            original_path=$(cat "$info_file" 2>/dev/null)
                            printf "%-7s | %-40s | %s\n" "$hash" "$basename" "$original_path"
                        else
                            printf "%-7s | %-40s | %s\n" "$hash" "$basename" "(unknown)"
                        fi
                        has_files=1
                    done
                fi
            done < <(get_all_trash_dirs)

            if [ $has_files -eq 0 ]; then
                echo "Trash is empty"
            fi
            ;;
        --undo|-u)
            local entry
            entry=$(pop_from_undo_stack)
            if [ $? -ne 0 ]; then
                echo "ERROR: Nothing to undo (undo stack is empty)"
                return 1
            fi

            local trash_name="${entry%|*}"
            local trash_dir="${entry#*|}"
            local trash_file="$trash_dir/files/$trash_name"
            local info_file="$trash_dir/info/${trash_name}.info"

            if [ ! -e "$trash_file" ]; then
                echo "ERROR: Trashed file no longer exists: $trash_file"
                return 1
            fi

            if [ ! -f "$info_file" ]; then
                echo "ERROR: No info file found for $trash_name"
                return 1
            fi

            local original_path=$(cat "$info_file" 2>/dev/null)
            local original_dir=$(dirname "$original_path")
            local original_name=$(basename "$original_path")

            if [ ! -d "$original_dir" ]; then
                echo "WARNING: Original directory '$original_dir' no longer exists"
                echo "Restoring to current directory instead"
                original_dir="."
            fi

            if [ -e "$original_dir/$original_name" ]; then
                original_name="${original_name}_restored_$(date +%s)"
                echo "WARNING: File already exists, restoring as '$original_name'"
            fi

            if mv "$trash_file" "$original_dir/$original_name" 2>/dev/null; then
                /bin/rm -f "$info_file" 2>/dev/null
                echo "Restored '$original_name' to '$original_dir/'"
            else
                echo "ERROR: Failed to restore file"
                echo "${trash_name}|${trash_dir}" >> "$UNDO_STACK"
                return 1
            fi
            ;;
        --restore|-s)
            shift
            if [ -z "$1" ]; then
                echo "ERROR: Please provide a hash to restore"
                echo "Usage: rm --restore <hash>"
                return 1
            fi

            local target_hash="$1"
            local found_file=""
            local found_basename=""
            local found_trash_dir=""

            while IFS= read -r trash_dir; do
                local trash_files="$trash_dir/files"

                if [ -d "$trash_files" ]; then
                    for file in "$trash_files"/*; do
                        [ -e "$file" ] || continue
                        basename="$(basename "$file")"
                        hash=$(echo -n "$basename" | sha256sum | cut -c1-6)
                        if [ "$hash" = "$target_hash" ]; then
                            found_file="$file"
                            found_basename="$basename"
                            found_trash_dir="$trash_dir"
                            break 2
                        fi
                    done
                fi
            done < <(get_all_trash_dirs)

            if [ -z "$found_file" ]; then
                echo "ERROR: No file found with hash '$target_hash'"
                echo "Use 'rm --list-trash' to see available files"
                return 1
            fi

            info_file="$found_trash_dir/info/${found_basename}.info"
            if [ ! -f "$info_file" ]; then
                echo "ERROR: No info file found for hash $target_hash"
                return 1
            fi

            original_path=$(cat "$info_file" 2>/dev/null)
            original_dir=$(dirname "$original_path")
            original_name=$(basename "$original_path")

            if [ ! -d "$original_dir" ]; then
                echo "WARNING: Original directory '$original_dir' no longer exists"
                echo "Restoring to current directory instead"
                original_dir="."
            fi

            if [ -e "$original_dir/$original_name" ]; then
                original_name="${original_name}_restored_$(date +%s)"
                echo "WARNING: File already exists, restoring as '$original_name'"
            fi

            if mv "$found_file" "$original_dir/$original_name" 2>/dev/null; then
                /bin/rm -f "$info_file" 2>/dev/null
                echo "Restored '$original_name' to '$original_dir/'"
            else
                echo "ERROR: Failed to restore file"
                return 1
            fi
            ;;
        --show-trash-path|-p)
            echo "Home trash: $HOME_TRASH_DIR"
            echo "All trash directories:"
            get_all_trash_dirs
            ;;
        --version)
            echo "rm-safely version: $VERSION"
            ;;
        --help)
            cat <<HELP
rm-safely - Files moved to trash before deletion
Usage: rm [options] [files...]

Files on the same filesystem as \$HOME go to ~/.local/share/Trash
Files on other filesystems go to <mountpoint>/.Trash-<uid>

Options:
  --rm                      Skip trash!, really execute 'rm'
  --list-trash, -l          Show trash contents from all filesystems
  --restore <hash>, -s      Restore a file from trash using its hash
  --undo, -u                Restore the last deleted files
  --empty-trash             Empty all trash directories
  --show-trash-path, -p     Display all trash directory paths
  --version                 Show version information
  --help                    Show this help
HELP
            ;;
        *)
            local failed=0
            for arg in "$@"; do

                [[ "$arg" == -* ]] && continue

                if [ ! -e "$arg" ] && [ ! -L "$arg" ]; then
                    echo "rm: cannot remove '$arg': No such file or directory"
                    failed=1
                    continue
                fi

                if [[ "$arg" = /* ]]; then
                    absolute_path="$arg"
                else
                    absolute_path="$(pwd)/$arg"
                fi

                local TRASH_DIR=$(get_trash_dir "$absolute_path")
                local TRASH_FILES="${TRASH_DIR}/files"
                local TRASH_INFO="${TRASH_DIR}/info"

                if ! mkdir -p "$TRASH_FILES" "$TRASH_INFO" 2>/dev/null; then
                    echo "WARNING: Cannot create trash directory at $TRASH_DIR"
                    echo "Falling back to home trash..."
                    TRASH_DIR="$HOME_TRASH_DIR"
                    TRASH_FILES="${TRASH_DIR}/files"
                    TRASH_INFO="${TRASH_DIR}/info"
                fi

                if ! [ -w "$TRASH_FILES" ]; then
                    echo "ERROR: Cannot write to: $TRASH_FILES"
                    failed=1
                    continue
                fi

                basename=$(basename "$arg")
                trash_name="${basename}_$(date +%s%N)"

                if mv "$arg" "$TRASH_FILES/$trash_name" 2>/dev/null; then
                    echo "$absolute_path" > "$TRASH_INFO/${trash_name}.info"
                    add_to_undo_stack "$trash_name" "$TRASH_DIR"
                    [ -d "$TRASH_FILES/$trash_name" ] && echo "Moved directory '$arg' to trash" || echo "Moved '$arg' to trash"
                else
                    echo "ERROR: Failed to move '$arg' to trash"
                    failed=1
                fi
            done

            return $failed
            ;;
    esac
}
EOF
    sed -i "s/__VERSION_PLACEHOLDER__/\"$VERSION\"/" "$HOOK_FILE"
}

install_hook() {
    detect_shell
    print_info "Installing rm-safely hook..."
    create_hook_file

    if ! grep -q "source.*\.rm-safely" "$SHELL_CONFIG" 2>/dev/null; then
        echo -e "\n# rm-safely - Safe rm command\nsource \"$HOOK_FILE\" >/dev/null 2>&1" >>"$SHELL_CONFIG"
        print_info "Added hook to $SHELL_CONFIG"
    else
        print_warning "Hook already exists in $SHELL_CONFIG"
    fi

    print_info "Installation complete!"
    print_warning "Restart your terminal or run 'source $SHELL_CONFIG' to activate"
}

uninstall_hook() {
    detect_shell
    print_info "Uninstalling rm-safely hook..."

    [ -f "$HOOK_FILE" ] && rm "$HOOK_FILE" && print_info "Removed hook file"

    if [ -f "$SHELL_CONFIG" ]; then
        sed -i.bak '/# rm-safely - Safe rm command/,+1d' "$SHELL_CONFIG"
        rm "${SHELL_CONFIG}.bak" 2>/dev/null
        print_info "Removed hook from $SHELL_CONFIG"
    fi

    print_info "Uninstallation complete!"
    print_warning "Restart your terminal to fully remove the hook"
}

status_hook() {
    detect_shell
    echo "rm-safely status:"
    echo "================="

    if [ -f "$HOOK_FILE" ]; then
        print_info "Hook file exists"
    else
        print_error "Hook file not found"
    fi

    if grep -q "source.*\.rm-safely" "$SHELL_CONFIG" 2>/dev/null; then
        print_info "Hook is enabled in $SHELL_CONFIG"
    else
        print_error "Hook not found in $SHELL_CONFIG"
    fi

    if type rm | grep -q "function"; then
        print_info "rm function is activated"
        local home_trash="${HOME}/.local/share/Trash"
        echo "Trash directory: $home_trash"
        if [ -d "$home_trash/files" ]; then
            file_count=$(find "$home_trash/files" -type f 2>/dev/null | wc -l)
            echo "Files in trash: $file_count"
        fi
    else
        print_warning "rm function is not activated"
    fi
}

case "${1:-}" in
install) install_hook ;;
uninstall) uninstall_hook ;;
status) status_hook ;;
version) echo "rm-safely version $VERSION" ;;
*)
    cat <<USAGE
rm-safely Installer
===================

Usage: $0 {install|uninstall|status|version}

Commands:
  install    Install the rm-safely
  uninstall  Remove the rm-safely
  status     Show installation status
  version    Show version information

USAGE
    ;;
esac
